---
title: Generalized Birthday Problem
author: Chang-Yu Chang
date: '2018-03-14'
slug: generalized-birthday-problem
categories:
  - R
tags:
  - fun
  - academic
  - R
---



<p>This tiny project comes from the coding class I am taking this semester. The simplest birthday problem is as followed: how many people should be in a room such that the probability of a birthday shared by at least two persons is just above 0.5? I found this problem is very interesting. Throughout the process dealing this problem, some powerful R packages and essential coding skills are incorporated for more efficient simulation. In this project, I will try to address generalized birthday problem from very first approach (easy coding but computer expensive and slow) to somehow more advanced approach.</p>
<p>Here is the outline for this article</p>
<ul>
<li><p><a href="https://changyuchang.netlify.com/post/generalized-birthday-problem/#what&#39;s-probability-of-one-birthday-shared-by-two-persons-in-any-size-of-room?">What’s probability of one birthday shared by two persons in any size of room?</a></p></li>
<li><p><a href="">Binary search</a></p></li>
<li><p><a href="">Dynamical number of replicate</a></p></li>
</ul>
<div id="whats-probability-of-one-birthday-shared-by-two-persons-in-any-size-of-room" class="section level3">
<h3>What’s probability of one birthday shared by two persons in any size of room?</h3>
<p>The probability we are interested calculated such that a birthday shared by at least <em>k</em> persons. The targeted probability <em>p</em> here is 0.5. For each room size <em>i</em>, <em>r</em> replicates are tested.</p>
<p>In the following case, I did only 20 replicates.</p>
<pre class="r"><code>k &lt;- 2                # Birthday shared by k persons
p &lt;- 0.5              # Targetd probability
r &lt;- 20               # Replicates
result &lt;- rep(0, 100) # A vector for saving result 
i &lt;- 10                  # Room size</code></pre>
<p>Now here is trick. For each room size, create a single matrix that has <em>r</em> rows and <em>i</em> columns. The next step is to check by row: if there are at least <em>k=2</em> persons in one room (<em>i=10</em>) sharing the same birthday, return <code>TRUE</code>. Use <code>apply</code> to implicitly loop through each row. The result probability would be the sum of this vector divided by total replicate <em>r</em>.</p>
<pre class="r"><code>set.seed(12345)
birth &lt;- matrix(sample(1:365, r*i, replace=TRUE), nrow=r, ncol=i)
birth</code></pre>
<pre><code>##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]  264  166  286  289  318  108  205  191  271    62
##  [2,]  320  120  157   95  188  226  188  254  218   150
##  [3,]  278  353  339  360    4  356   33   79  311    72
##  [4,]  324  259  283  277    8  226  250  230  298    95
##  [5,]  167  236   95  358   53  191  260   54  139   355
##  [6,]   61  143  118   80  112  330  293  351  180   297
##  [7,]  119  255   22  347  302  233  345  362  363   127
##  [8,]  186  199   16   55  184  316   69  182   64   343
##  [9,]  266   83   21  220  294   92  102  336  305    60
## [10,]  362  177  229  346   23   79  283  136  145    58
## [11,]   13  290  353  252  339  223   13  302  354   276
## [12,]   56    3  302  185  295  140  246  205   69   324
## [13,]  269   69  115  137   29  276  297  291  274   112
## [14,]    1  249   78  123  220  139  243  129  113   114
## [15,]  143  136  268   18  261  291  345   77  139   360
## [16,]  169  132  183  226  188  331  320  287  275     3
## [17,]  142  318  267  351  263  360  255  250  258   101
## [18,]  147  331   30  240  274  215   68  158  337   292
## [19,]   66  226  159  187   35    4   36  309  291    89
## [20,]  348   49   87   55  146  118  295  220  303   168</code></pre>
<p>The probability for 2 persons sharing the same birthday in a room with 10 persones is roughly 0.1.</p>
<pre class="r"><code>sum(apply(birth, 1, function(x) max(tabulate(x))&gt;=k )) / r</code></pre>
<pre><code>## [1] 0.1</code></pre>
<p>Now test different room sizes. Say I wanna test room sizes ranging from <em>k</em> to 100 (testing room size smaller than <em>k</em> is nonsense). Use <code>for</code> loop to go through room size from k to 100.</p>
<pre class="r"><code>k &lt;- 2                # Birthday shared by k persons
p &lt;- 0.5              # Targetd probability
r &lt;- 100000           # Replicates
result &lt;- rep(0, 100) # A vector for saving result 

system.time({         # Record time used
for (i in 1:100) {    # Test room sizes from 1 to 100 persons
  birth &lt;- matrix(sample(1:365, r*i, replace=TRUE), nrow=r, ncol=i)
  result[i] &lt;- sum(apply(birth, 1, function(x) max(tabulate(x))&gt;=k )) / r
}
})</code></pre>
<pre><code>##    user  system elapsed 
##  55.684   4.624  60.952</code></pre>
<p>This simulation is extremely slow. Something is pretty obvious, for example, if I already know the result is going to be 23 just after calculating it, I don’t need to do the else (24-100), which consumes tons of time. I will show you some ways to speed up and accurate the simulation, including binary search, dynamical tested replicate, and Rcpp package.</p>
<pre class="r"><code>plot(result, type=&quot;l&quot;, xlab=&quot;room size&quot;, ylab=&quot;probability&quot;, main=&quot;probability of a birthday shared by k persons&quot;)
abline(h=p, col=&quot;red&quot;) </code></pre>
<p><img src="/post/2018-03-14-generalized-birthday-problem_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>The answer is 23 persons.</p>
<pre class="r"><code>min(which(result&gt;p))</code></pre>
<pre><code>## [1] 23</code></pre>
</div>
<div id="binary-search" class="section level3">
<h3>Binary search</h3>
<p>If I know where I stand is still far away from the target probability, can I apply a larger step, not step-by-step, in order to move quickly? A good way is to employ binary search algorithm. The key concept is to skip unecessary mid-points (in our case, room sizes) for saving computer time. Given a series of <em>n</em> sorted room sizes ranging from lower bound <span class="math inline">\(L=1\)</span> to upper bound <span class="math inline">\(R=n\)</span>, then the corresponding probability of at least k people sharing the same birthday are <span class="math inline">\(p_1, p_2, \dots, p_n\)</span>). Our goal is to find the probability of room size that is close and slightly large than 0.5 <span class="math inline">\(p_t=0.5\)</span>. Here is the procedure:</p>
<ol style="list-style-type: decimal">
<li>Set L to 1 and R to n. R would be always larger than L.</li>
<li>Calculate i (position fo the middle element). Set i to floor since the room size should be an integer.</li>
<li>If <span class="math inline">\(p_i&lt;p_t\)</span>, set L to i + 1 and go to step 2.</li>
<li>If <span class="math inline">\(p_i&gt;p_t\)</span>, set R to i − 1 and go to step 2.</li>
<li>Repeat step 2-4 until <span class="math inline">\(p_i=p_t\)</span>, the search is done. m is our answer.</li>
</ol>
<pre class="r"><code>k &lt;- 2                # Birthday shared by k persons
p &lt;- 0.5              # Targetd probability
r &lt;- 100000           # Replicates
result &lt;- rep(0, 100) # A vector for saving result 

gbp &lt;- function(k=2, p=.5, r=100000, threshold=.001) {
  i &lt;- k                       # Tested room size; start from k persons in a room
  x &lt;- 2                       # Counter for while loop
  result &lt;- setNames(data.frame(matrix(0, 100, 2)), c(&quot;room&quot;, &quot;p&quot;))
  L &lt;- 0                       # Lower bound for binary search
  R &lt;- k^4+100+sample(-k:k, 1) # Upper bound for binary search
  result$room[x-1] &lt;- R
 while (abs(result$room[x-1] - p) &gt;= threshold) {
    # Tested room size
    i &lt;- floor((L+R)/2)
    result$room[x] &lt;- i

    # Calculate probability
    birth &lt;- matrix(sample(1:365, r*i, replace=TRUE), nrow=r, ncol=i)
    result$p[x] &lt;- sum(apply(birth, 1, function(x) max(tabulate(x))&gt;=k )) / r
    if (result$p[x] &gt;= p) R &lt;- i
    if (result$p[x] &lt; p) L &lt;- i
    
    if(result$room[x] == result$room[x-1] &amp; result$room[x] != 0) break
    x &lt;- x + 1           # Counter
 
    cat(paste0(&#39;\n&#39;, i))
 }
  ans &lt;- R
  return(list(answer=ans,
              result=result[1:x,]))
}

system.time(y&lt;-gbp(k=2, p=.5))</code></pre>
<pre><code>## 
## 57
## 28
## 14
## 21
## 24
## 22
## 23
## 22</code></pre>
<pre><code>##    user  system elapsed 
##   4.504   0.216   4.836</code></pre>
<pre class="r"><code>y</code></pre>
<pre><code>## $answer
## [1] 23
## 
## $result
##    room       p
## 1   114 0.00000
## 2    57 0.98982
## 3    28 0.65560
## 4    14 0.22179
## 5    21 0.44360
## 6    24 0.53638
## 7    22 0.47481
## 8    23 0.50815
## 9    22 0.47644
## 10   22 0.47736</code></pre>
</div>
<div id="dynamical-number-of-replicate" class="section level3">
<h3>Dynamical number of replicate</h3>
</div>
