---
title: Generalized Birthday Problem
author: Chang-Yu Chang
date: '2018-03-14'
slug: generalized-birthday-problem
categories:
  - R
tags:
  - fun
  - academic
  - R
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```
This tiny project comes from the coding class I am taking this semester. The simplest birthday problem is as followed: how many people should be in a room such that the probability of a birthday shared by at least two persons is just above 0.5? I found this problem is very interesting. Throughout the process dealing this problem, some powerful R packages and essential coding skills are incorporated for more efficient simulation. In this project, I will try to address generalized birthday problem from very first approach (easy coding but computer expensive and slow) to somehow more advanced approach. 

Here is the outline for this article

- [What's probability of one birthday shared by two persons in any size of room?](https://changyuchang.netlify.com/post/generalized-birthday-problem/#what's-probability-of-one-birthday-shared-by-two-persons-in-any-size-of-room?)

- [Binary search]()

- [Dynamical number of replicate]()

### What's probability of one birthday shared by two persons in any size of room?

The probability we are interested calculated such that a birthday shared by at least *k* persons. The targeted probability *p* here is 0.5. For each room size *i*, *r* replicates are tested. 

In the following case, I did only 20 replicates. 
```{r}
k <- 2                # Birthday shared by k persons
p <- 0.5              # Targetd probability
r <- 20               # Replicates
result <- rep(0, 100) # A vector for saving result 
i <- 10                  # Room size
```

Now here is trick. For each room size, create a single matrix that has *r* rows and *i* columns. The next step is to check by row: if there are at least *k=2* persons in one room (*i=10*) sharing the same birthday, return `TRUE`. Use `apply` to implicitly loop through each row. The result probability would be the sum of this vector divided by total replicate *r*.
```{r}
set.seed(12345)
birth <- matrix(sample(1:365, r*i, replace=TRUE), nrow=r, ncol=i)
birth
```
The probability for 2 persons sharing the same birthday in a room with 10 persones is roughly 0.1. 
```{r}
sum(apply(birth, 1, function(x) max(tabulate(x))>=k )) / r
```

Now test different room sizes. Say I wanna test room sizes ranging from *k* to 100 (testing room size smaller than *k* is nonsense). Use `for` loop to go through room size from k to 100. 
```{r}
k <- 2                # Birthday shared by k persons
p <- 0.5              # Targetd probability
r <- 100000           # Replicates
result <- rep(0, 100) # A vector for saving result 

system.time({         # Record time used
for (i in 1:100) {    # Test room sizes from 1 to 100 persons
  birth <- matrix(sample(1:365, r*i, replace=TRUE), nrow=r, ncol=i)
  result[i] <- sum(apply(birth, 1, function(x) max(tabulate(x))>=k )) / r
}
})
```

This simulation is extremely slow. Something is pretty obvious, for example, if I already know the result is going to be 23 just after calculating it, I don't need to do the else (24-100), which consumes tons of time. I will show you some ways to speed up and accurate the simulation, including binary search, dynamical tested replicate, and Rcpp package.
```{r}
plot(result, type="l", xlab="room size", ylab="probability", main="probability of a birthday shared by k persons")
abline(h=p, col="red") 
```

The answer is 23 persons. 
```{r}
min(which(result>p))
```

### Binary search
If I know where I stand is still far away from the target probability, can I apply a larger step, not step-by-step, in order to move quickly? A good way is to employ binary search algorithm. The key concept is to skip unecessary mid-points (in our case, room sizes) for saving computer time. Given a series of *n* sorted room sizes ranging from lower bound $L=1$ to upper bound $R=n$, then the corresponding probability of at least k people sharing the same birthday are $p_1, p_2, \dots, p_n$). Our goal is to find the probability of room size that is close and slightly large than 0.5 $p_t=0.5$. Here is the procedure:

1. Set L to 1 and R to n. R would be always larger than L.
2. Calculate i (position fo the middle element). Set i to floor since the room size should be an integer. 
3. If $p_i<p_t$, set L to i + 1 and go to step 2.
4. If $p_i>p_t$, set R to i âˆ’ 1 and go to step 2.
5. Repeat step 2-4 until $p_i=p_t$, the search is done. m is our answer.

```{r}
k <- 2                # Birthday shared by k persons
p <- 0.5              # Targetd probability
r <- 100000           # Replicates
result <- rep(0, 100) # A vector for saving result 

gbp <- function(k=2, p=.5, r=100000, threshold=.001) {
  i <- k                       # Tested room size; start from k persons in a room
  x <- 2                       # Counter for while loop
  result <- setNames(data.frame(matrix(0, 100, 2)), c("room", "p"))
  L <- 0                       # Lower bound for binary search
  R <- k^4+100+sample(-k:k, 1) # Upper bound for binary search
  result$room[x-1] <- R
 while (abs(result$room[x-1] - p) >= threshold) {
    # Tested room size
    i <- floor((L+R)/2)
    result$room[x] <- i

    # Calculate probability
    birth <- matrix(sample(1:365, r*i, replace=TRUE), nrow=r, ncol=i)
    result$p[x] <- sum(apply(birth, 1, function(x) max(tabulate(x))>=k )) / r
    if (result$p[x] >= p) R <- i
    if (result$p[x] < p) L <- i
    
    if(result$room[x] == result$room[x-1] & result$room[x] != 0) break
    x <- x + 1           # Counter
 
    cat(paste0('\n', i))
 }
  ans <- R
  return(list(answer=ans,
              result=result[1:x,]))
}

system.time(y<-gbp(k=2, p=.5))
y
  
```


### Dynamical number of replicate




