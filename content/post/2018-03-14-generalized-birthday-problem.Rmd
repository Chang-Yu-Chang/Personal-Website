---
title: Generalized Birthday Problem
author: Chang-Yu Chang
date: '2018-03-14'
slug: generalized-birthday-problem
categories:
  - R
tags:
  - fun
  - academic
  - R
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```
This tiny project comes from the coding class I am taking this semester. The simplest birthday problem is as followed: how many people should be in a room such that the probability of a birthday shared by at least two persons is just above 0.5? I found this problem is very interesting. Throughout the process dealing this problem, some powerful R packages and essential coding skills are incorporated for more efficient simulation. In this project, I will try to address generalized birthday problem from very first approach (easy coding but computer expensive and slow) to somehow more advanced approach. 

Here is the outline for this article

- [What's probability of one birthday shared by two persons in any size of room?](https://changyuchang.netlify.com/post/generalized-birthday-problem/#what's-probability-of-one-birthday-shared-by-two-persons-in-any-size-of-room?)

- [Binary search]()

- [Dynamical number of replicate]()

### What's probability of one birthday shared by two persons in any size of room?

The probability we are interested calculated such that a birthday shared by at least *k* persons. The targeted probability *p* here is 0.5. For each room size *i*, *r* replicates are tested. 

In the following case, I did only 20 replicates. 
```{r}
k <- 2                # Birthday shared by k persons
p <- 0.5              # Targetd probability
r <- 20               # Replicates
result <- rep(0, 100) # A vector for saving result 
i <- 10                  # Room size
```

Now here is trick. For each room size, create a single matrix that has *r* rows and *i* columns. The next step is to check by row: if there are at least *k=2* persons in one room (*i=10*) sharing the same birthday, return `TRUE`. Use `apply` to implicitly loop through each row. The result probability would be the sum of this vector divided by total replicate *r*.
```{r}
set.seed(12345)
birth <- matrix(sample(1:365, r*i, replace=TRUE), nrow=r, ncol=i)
birth
```
The probability for 2 persons sharing the same birthday in a room with 10 persones is roughly 0.1. 
```{r}
sum(apply(birth, 1, function(x) max(tabulate(x))>=k )) / r
```

Now test different room sizes. Say I wanna test room sizes ranging from *k* to 100 (testing room size smaller than *k* is nonsense). Use `for` loop to go through room size from k to 100. 
```{r}
k <- 2                # Birthday shared by k persons
p <- 0.5              # Targetd probability
r <- 100000           # Replicates
result <- rep(0, 100) # A vector for saving result 

system.time({         # Record time used
for (i in 1:100) {    # Test room sizes from 1 to 100 persons
  birth <- matrix(sample(1:365, r*i, replace=TRUE), nrow=r, ncol=i)
  result[i] <- sum(apply(birth, 1, function(x) max(tabulate(x))>=k )) / r
}
})
```

This simulation is extremely slow. Something is pretty obvious, for example, if I already know the result is going to be 23 just after calculating it, I don't need to do the else (24-100), which consumes tons of time. I will show you some ways to speed up and accurate the simulation, including binary search, dynamical tested replicate, and Rcpp package.
```{r}
plot(result, type="l", xlab="room size", ylab="probability", main="probability of a birthday shared by k persons")
abline(h=p, col="red") 
```

The answer is 23 persons. 
```{r}
min(which(result>p))
```

### Binary search

### Dynamical number of replicate




